# 数据架构分析与优化方案

> **分析时间**: 2026-01-17  
> **分析目标**: 页面数据加载与组件关系、耦合度、数据管理优化  
> **结论**: 需要重构为JSON数据集架构

---

## 一、当前架构分析

### 1.1 数据生成方式

#### 当前实现

```typescript
// frontend/src/mock/project-mock.ts
export function generateMockProjects(count: number = 3): DomainProject[] {
  return Array.from({ length: count }, (_, i) => {
    const projectId = generateId('proj')
    return {
      id: projectId,
      code: generateCode('PRJ', i + 1),
      name: `${randomChoice(DOMAIN_OPTIONS)}领域项目`,
      // ... 动态生成
    }
  })
}
```

**特点**:
- ❌ 硬编码的生成逻辑
- ❌ 每次刷新数据都不同
- ❌ 难以预测和测试
- ❌ 无法进行精细的数据设计

---

### 1.2 页面与数据的关系

#### 数据流向

```
页面组件
  ↓ (useXxxStore)
Pinia Store
  ↓ (mockDataInitializer)
Mock生成器函数
  ↓ (generateMockXxx)
随机生成的数据
```

#### 耦合度分析

| 层级 | 组件 | 耦合程度 | 问题 |
|------|------|----------|------|
| **页面层** | ProjectList.vue | ⚠️ 中度耦合 | 依赖Store结构 |
| **Store层** | projectStore | ✅ 解耦良好 | 标准Pinia模式 |
| **数据层** | mockDataInitializer | ❌ 高度耦合 | 硬编码初始化逻辑 |
| **生成层** | generateMockProjects | ❌ 硬编码 | 逻辑分散，难以维护 |

---

### 1.3 当前数据关系维护

#### 示例：Epic-Feature关系

```typescript
// mockDataInitializer.ts
for (const epic of hierarchy.epics) {
  if (projectPIs.length > 0) {
    const targetPI = projectPIs[Math.floor(Math.random() * projectPIs.length)]
    epic.targetPI = targetPI.id  // 手动维护关系
    
    if (!targetPI.epicIds.includes(epic.id)) {
      targetPI.epicIds.push(epic.id)  // 双向关联手动维护
    }
  }
}
```

**问题**:
1. ❌ 关系维护逻辑分散
2. ❌ 双向关联容易出错
3. ❌ 难以可视化数据关系
4. ❌ 修改数据需要改代码

---

## 二、主要问题总结

### 2.1 硬编码问题

| 问题 | 现状 | 影响 |
|------|------|------|
| **数据生成逻辑** | 硬编码在函数中 | 难以修改和扩展 |
| **数据关系** | 手动代码维护 | 容易出错 |
| **测试数据** | 随机生成 | 不可重复测试 |
| **数据设计** | 分散在多个文件 | 无法整体把控 |

### 2.2 耦合问题

```
❌ 当前架构（高耦合）

页面组件 ─────┐
             ├──> Store ──> Mock函数 ──> 硬编码逻辑
其他组件 ─────┘

问题：
1. 修改数据需要改代码
2. 数据设计分散
3. 难以版本管理
4. 测试数据不稳定
```

### 2.3 维护问题

**场景：需要添加一个新的项目**

当前流程：
1. 修改 `generateMockProjects` 函数
2. 增加计数参数或逻辑
3. 重新生成所有数据
4. 无法精确控制新项目的属性
5. 可能影响其他数据

**难度**: ⭐⭐⭐⭐（困难）

---

## 三、优化方案：JSON数据集架构

### 3.1 设计目标

✅ **解耦**: 数据与代码分离  
✅ **可维护**: JSON格式易于编辑  
✅ **可预测**: 固定数据便于测试  
✅ **可扩展**: 支持按需加载  
✅ **可管理**: 统一的数据集管理  
✅ **可追溯**: 数据关系清晰可查  

---

### 3.2 JSON数据集结构

#### 目录结构

```
frontend/src/mock-data/
├── datasets/                  # 数据集目录
│   ├── users.json            # 用户数据
│   ├── projects.json         # 项目数据
│   ├── versions.json         # 版本数据
│   ├── pis.json              # PI数据
│   ├── epics.json            # Epic数据
│   ├── features.json         # Feature数据
│   ├── ssts.json             # SSTS数据
│   ├── mrs.json              # MR数据
│   ├── sprints.json          # Sprint数据
│   ├── tasks.json            # Task数据
│   ├── testcases.json        # 测试用例数据
│   ├── defects.json          # 缺陷数据
│   ├── assets.json           # 资产数据
│   └── relations.json        # 关系映射（可选）
├── schemas/                   # 数据模式（可选）
│   ├── user.schema.json
│   ├── project.schema.json
│   └── ...
├── loaders/                   # 数据加载器
│   ├── DataLoader.ts         # 统一数据加载器
│   ├── RelationResolver.ts   # 关系解析器
│   └── QueryEngine.ts        # 查询引擎
└── index.ts                   # 导出
```

---

### 3.3 JSON数据示例

#### users.json

```json
{
  "version": "1.0.0",
  "updatedAt": "2026-01-17T10:00:00Z",
  "data": [
    {
      "id": "user-001",
      "name": "张三",
      "email": "zhangsan@example.com",
      "role": "项目经理",
      "department": "智能驾驶",
      "avatar": "https://example.com/avatar/zhangsan.jpg",
      "phone": "13800138000"
    },
    {
      "id": "user-002",
      "name": "李四",
      "email": "lisi@example.com",
      "role": "开发工程师",
      "department": "智能座舱",
      "avatar": "https://example.com/avatar/lisi.jpg",
      "phone": "13800138001"
    }
  ]
}
```

#### projects.json

```json
{
  "version": "1.0.0",
  "updatedAt": "2026-01-17T10:00:00Z",
  "data": [
    {
      "id": "proj-001",
      "code": "PRJ-001",
      "name": "智能驾驶L3级功能开发",
      "domain": "智能驾驶",
      "vehicleModel": "岚图FREE 2026款",
      "description": "实现L3级自动驾驶功能，包括高速NOA、城市NGP等",
      "owner": "user-001",
      "startDate": "2026-01-01",
      "sopDate": "2026-12-31",
      "status": "in-progress",
      "health": "green",
      "milestones": [
        {
          "id": "ms-001",
          "name": "需求评审完成",
          "date": "2026-03-31",
          "status": "achieved",
          "description": "完成所有需求的评审和确认"
        },
        {
          "id": "ms-002",
          "name": "功能原型完成",
          "date": "2026-06-30",
          "status": "at-risk",
          "description": "完成核心功能的原型开发"
        }
      ],
      "teams": ["team-001", "team-002"],
      "objectives": [
        "实现高速公路自动驾驶",
        "通过功能安全认证",
        "完成10万公里路测"
      ]
    }
  ]
}
```

#### versions.json

```json
{
  "version": "1.0.0",
  "updatedAt": "2026-01-17T10:00:00Z",
  "data": [
    {
      "id": "ver-001",
      "code": "V1.0",
      "name": "版本 1.0 - 基础功能",
      "projectId": "proj-001",
      "description": "包含基础的L3级自动驾驶功能",
      "startDate": "2026-01-01",
      "releaseDate": "2026-06-30",
      "status": "in-progress",
      "featureIds": ["feat-001", "feat-002", "feat-003"],
      "releaseNotes": "1. 高速NOA\n2. 自动变道\n3. 匝道汇入"
    },
    {
      "id": "ver-002",
      "code": "V2.0",
      "name": "版本 2.0 - 增强功能",
      "projectId": "proj-001",
      "description": "增强的城市场景自动驾驶",
      "startDate": "2026-07-01",
      "releaseDate": "2026-12-31",
      "status": "planning",
      "featureIds": ["feat-004", "feat-005"],
      "releaseNotes": "1. 城市NGP\n2. 自动泊车"
    }
  ]
}
```

#### relations.json (可选)

```json
{
  "version": "1.0.0",
  "description": "实体关系映射",
  "relations": {
    "Project-Version": {
      "type": "one-to-many",
      "from": "projects",
      "to": "versions",
      "fromField": "id",
      "toField": "projectId"
    },
    "Project-PI": {
      "type": "many-to-many",
      "from": "projects",
      "to": "pis",
      "fromField": "piVersionIds",
      "toField": "projectIds"
    },
    "Epic-Feature": {
      "type": "one-to-many",
      "from": "epics",
      "to": "features",
      "fromField": "id",
      "toField": "epicId"
    }
  }
}
```

---

### 3.4 数据加载器设计

#### DataLoader.ts

```typescript
/**
 * 统一数据加载器
 * 负责从JSON文件加载数据到Store
 */

import usersData from '../datasets/users.json'
import projectsData from '../datasets/projects.json'
import versionsData from '../datasets/versions.json'
import pisData from '../datasets/pis.json'
import epicsData from '../datasets/epics.json'
import featuresData from '../datasets/features.json'

export interface DatasetMetadata {
  version: string
  updatedAt: string
  data: any[]
}

export class DataLoader {
  private datasets: Map<string, DatasetMetadata> = new Map()

  constructor() {
    this.loadAllDatasets()
  }

  /**
   * 加载所有数据集
   */
  private loadAllDatasets() {
    this.datasets.set('users', usersData)
    this.datasets.set('projects', projectsData)
    this.datasets.set('versions', versionsData)
    this.datasets.set('pis', pisData)
    this.datasets.set('epics', epicsData)
    this.datasets.set('features', featuresData)
  }

  /**
   * 获取数据集
   */
  getDataset<T = any>(name: string): T[] {
    const dataset = this.datasets.get(name)
    if (!dataset) {
      console.warn(`数据集 "${name}" 不存在`)
      return []
    }
    return dataset.data as T[]
  }

  /**
   * 根据ID查询单个实体
   */
  findById<T = any>(datasetName: string, id: string): T | undefined {
    const data = this.getDataset<T>(datasetName)
    return data.find((item: any) => item.id === id)
  }

  /**
   * 根据条件查询
   */
  findBy<T = any>(
    datasetName: string, 
    predicate: (item: T) => boolean
  ): T[] {
    const data = this.getDataset<T>(datasetName)
    return data.filter(predicate)
  }

  /**
   * 获取关联数据
   * @example
   * // 获取项目的所有版本
   * loader.getRelated('versions', 'projectId', 'proj-001')
   */
  getRelated<T = any>(
    datasetName: string,
    foreignKey: string,
    foreignValue: string
  ): T[] {
    const data = this.getDataset<T>(datasetName)
    return data.filter((item: any) => item[foreignKey] === foreignValue)
  }

  /**
   * 批量查询关联数据
   */
  getRelatedMany<T = any>(
    datasetName: string,
    foreignKey: string,
    foreignValues: string[]
  ): T[] {
    const data = this.getDataset<T>(datasetName)
    return data.filter((item: any) => 
      foreignValues.includes(item[foreignKey])
    )
  }

  /**
   * 获取数据集元信息
   */
  getMetadata(datasetName: string) {
    const dataset = this.datasets.get(datasetName)
    if (!dataset) return null
    
    return {
      version: dataset.version,
      updatedAt: dataset.updatedAt,
      count: dataset.data.length
    }
  }
}

// 单例
export const dataLoader = new DataLoader()
```

---

### 3.5 关系解析器设计

#### RelationResolver.ts

```typescript
/**
 * 关系解析器
 * 自动解析和填充实体间的关系
 */

import { dataLoader } from './DataLoader'

export class RelationResolver {
  /**
   * 解析项目的完整数据（包含关联）
   */
  resolveProject(projectId: string) {
    const project = dataLoader.findById('projects', projectId)
    if (!project) return null

    return {
      ...project,
      // 自动加载关联的版本
      versions: dataLoader.getRelated('versions', 'projectId', projectId),
      // 自动加载关联的PI
      pis: dataLoader.getRelated('pis', 'projectIds', projectId),
      // 自动加载关联的Epic
      epics: dataLoader.getRelated('epics', 'projectId', projectId),
      // 自动加载负责人信息
      ownerInfo: dataLoader.findById('users', project.owner)
    }
  }

  /**
   * 解析Epic的完整数据
   */
  resolveEpic(epicId: string) {
    const epic = dataLoader.findById('epics', epicId)
    if (!epic) return null

    return {
      ...epic,
      // 自动加载Features
      features: dataLoader.getRelated('features', 'epicId', epicId),
      // 自动加载目标PI
      targetPIInfo: epic.targetPI 
        ? dataLoader.findById('pis', epic.targetPI)
        : null,
      // 自动加载负责人
      ownerInfo: dataLoader.findById('users', epic.owner)
    }
  }

  /**
   * 批量解析（用于列表页面）
   */
  resolveMany(datasetName: string, ids: string[]) {
    return ids.map(id => {
      const resolveMethod = `resolve${capitalize(datasetName)}`
      if (typeof this[resolveMethod] === 'function') {
        return this[resolveMethod](id)
      }
      return dataLoader.findById(datasetName, id)
    })
  }
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

// 单例
export const relationResolver = new RelationResolver()
```

---

### 3.6 查询引擎设计

#### QueryEngine.ts

```typescript
/**
 * 查询引擎
 * 支持复杂的数据查询和筛选
 */

import { dataLoader } from './DataLoader'

export interface QueryOptions {
  filters?: Record<string, any>
  sort?: { field: string; order: 'asc' | 'desc' }
  pagination?: { page: number; pageSize: number }
  includes?: string[]  // 需要加载的关联数据
}

export class QueryEngine {
  /**
   * 通用查询方法
   */
  query<T = any>(datasetName: string, options: QueryOptions = {}): {
    data: T[]
    total: number
    page?: number
    pageSize?: number
  } {
    let data = dataLoader.getDataset<T>(datasetName)

    // 应用筛选
    if (options.filters) {
      data = this.applyFilters(data, options.filters)
    }

    // 应用排序
    if (options.sort) {
      data = this.applySort(data, options.sort)
    }

    const total = data.length

    // 应用分页
    if (options.pagination) {
      data = this.applyPagination(data, options.pagination)
    }

    return {
      data,
      total,
      page: options.pagination?.page,
      pageSize: options.pagination?.pageSize
    }
  }

  /**
   * 应用筛选条件
   */
  private applyFilters<T>(data: T[], filters: Record<string, any>): T[] {
    return data.filter(item => {
      return Object.entries(filters).every(([key, value]) => {
        if (value === undefined || value === null || value === '') {
          return true
        }
        
        const itemValue = (item as any)[key]
        
        // 支持数组包含查询
        if (Array.isArray(value)) {
          return value.includes(itemValue)
        }
        
        // 支持模糊查询（字符串）
        if (typeof value === 'string' && typeof itemValue === 'string') {
          return itemValue.toLowerCase().includes(value.toLowerCase())
        }
        
        // 精确匹配
        return itemValue === value
      })
    })
  }

  /**
   * 应用排序
   */
  private applySort<T>(
    data: T[], 
    sort: { field: string; order: 'asc' | 'desc' }
  ): T[] {
    return [...data].sort((a, b) => {
      const aValue = (a as any)[sort.field]
      const bValue = (b as any)[sort.field]
      
      if (aValue < bValue) return sort.order === 'asc' ? -1 : 1
      if (aValue > bValue) return sort.order === 'asc' ? 1 : -1
      return 0
    })
  }

  /**
   * 应用分页
   */
  private applyPagination<T>(
    data: T[],
    pagination: { page: number; pageSize: number }
  ): T[] {
    const start = (pagination.page - 1) * pagination.pageSize
    const end = start + pagination.pageSize
    return data.slice(start, end)
  }

  /**
   * 聚合查询
   */
  aggregate(datasetName: string, aggregations: {
    count?: boolean
    groupBy?: string
    sum?: string
    avg?: string
  }) {
    const data = dataLoader.getDataset(datasetName)

    if (aggregations.count) {
      return { count: data.length }
    }

    if (aggregations.groupBy) {
      const groups: Record<string, any[]> = {}
      data.forEach(item => {
        const key = item[aggregations.groupBy!]
        if (!groups[key]) {
          groups[key] = []
        }
        groups[key].push(item)
      })
      return groups
    }

    // 更多聚合逻辑...
  }
}

// 单例
export const queryEngine = new QueryEngine()
```

---

## 四、重构后的架构

### 4.1 新的数据流

```
✅ 优化后架构（低耦合）

页面组件
  ↓ (useXxxStore)
Pinia Store
  ↓ (DataLoader / QueryEngine)
JSON数据集
  ↓
固定的、可管理的数据

优点：
1. 数据与代码分离
2. 数据集统一管理
3. 支持按需加载
4. 关系自动解析
5. 易于测试和维护
```

### 4.2 Store重构

#### Before

```typescript
// projectStore
async function fetchProjects() {
  // 从mockDataInitializer生成的内存数据获取
  await new Promise(resolve => setTimeout(resolve, 500))
}
```

#### After

```typescript
// projectStore
import { dataLoader, queryEngine } from '@/mock-data/loaders'

async function fetchProjects(options?: QueryOptions) {
  loading.value = true
  try {
    // 从JSON数据集加载
    const result = queryEngine.query('projects', options)
    projects.value = result.data
    
    // 自动解析关联（可选）
    if (options?.includes) {
      projects.value = projects.value.map(p => 
        relationResolver.resolveProject(p.id)
      )
    }
  } finally {
    loading.value = false
  }
}
```

---

## 五、对比分析

### 5.1 架构对比

| 维度 | 当前架构 | JSON数据集架构 |
|------|---------|---------------|
| **数据来源** | 函数生成 | JSON文件 |
| **数据稳定性** | 随机 | 固定 |
| **可维护性** | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **可测试性** | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **扩展性** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **耦合度** | 高 | 低 |
| **查询性能** | 中 | 高 |
| **数据管理** | 分散 | 集中 |

### 5.2 功能对比

| 功能 | 当前实现 | JSON架构 |
|------|---------|----------|
| **添加数据** | 修改代码 | 编辑JSON |
| **修改数据** | 修改代码 | 编辑JSON |
| **数据版本管理** | ❌ 不支持 | ✅ Git版本控制 |
| **按需加载** | ❌ 全量加载 | ✅ 支持 |
| **关系查询** | ⚠️ 手动维护 | ✅ 自动解析 |
| **复杂筛选** | ⚠️ 每个页面实现 | ✅ 统一QueryEngine |
| **数据导入导出** | ❌ 不支持 | ✅ 原生支持 |

---

## 六、实施建议

### 6.1 分阶段实施

#### Phase 1: 基础设施（1-2天）
- ✅ 创建JSON数据集目录结构
- ✅ 实现DataLoader
- ✅ 实现QueryEngine
- ✅ 创建初始JSON数据文件

#### Phase 2: 核心实体迁移（2-3天）
- ✅ User、Project、Version、PI
- ✅ 更新对应的Store
- ✅ 测试核心功能

#### Phase 3: 需求实体迁移（2-3天）
- ✅ Epic、Feature、SSTS、MR
- ✅ 实现RelationResolver
- ✅ 测试关联查询

#### Phase 4: 执行实体迁移（1-2天）
- ✅ Sprint、Task、TestCase、Defect
- ✅ 完善QueryEngine
- ✅ 性能优化

#### Phase 5: 完善与优化（1-2天）
- ✅ Asset等其他实体
- ✅ 文档补充
- ✅ 全面测试

### 6.2 兼容性策略

**渐进式迁移**:
```typescript
// 支持两种数据源
const USE_JSON_DATASET = true  // 开关

async function fetchProjects() {
  if (USE_JSON_DATASET) {
    // 从JSON加载
    return queryEngine.query('projects')
  } else {
    // 旧的函数生成方式
    return generateMockProjects(3)
  }
}
```

---

## 七、额外收益

### 7.1 数据治理

✅ **数据质量**
- 固定数据便于验证
- 可以进行数据一致性检查
- 便于发现数据问题

✅ **数据文档化**
- JSON即文档
- 易于理解数据结构
- 便于团队协作

### 7.2 开发体验

✅ **快速原型**
- 快速修改测试数据
- 无需重启服务
- 支持热更新（HMR）

✅ **调试友好**
- 数据可追溯
- 易于定位问题
- 支持数据快照

### 7.3 测试支持

✅ **E2E测试**
- 固定数据确保测试可重复
- 支持测试场景预设
- 便于自动化测试

✅ **数据驱动测试**
- 可以准备多套测试数据
- 支持边界条件测试
- 便于回归测试

---

## 八、总结

### 当前架构问题

1. ❌ **高耦合**: 数据生成逻辑硬编码
2. ❌ **难维护**: 修改数据需要改代码
3. ❌ **不稳定**: 随机数据影响测试
4. ❌ **分散管理**: 数据逻辑分散在多个文件

### JSON数据集方案优势

1. ✅ **低耦合**: 数据与代码分离
2. ✅ **易维护**: 编辑JSON即可
3. ✅ **可预测**: 固定数据便于测试
4. ✅ **统一管理**: 集中的数据集目录

### 推荐实施

**建议**: ✅ **立即实施JSON数据集架构**

**理由**:
1. 当前Mock数据规模不大，迁移成本可控
2. 长远看大幅提升开发和测试效率
3. 符合数据驱动开发最佳实践
4. 便于后续对接真实后端API

---

**文档版本**: V1.0  
**生成时间**: 2026-01-17  
**下一步**: 实施JSON数据集架构重构
